// @ts-nocheck
import NextAuth from "next-auth";
import GoogleProvider from "next-auth/providers/google";
import CredentialsProvider from "next-auth/providers/credentials";
import { NextApiRequest, NextApiResponse } from "next";
import jwt from "jsonwebtoken";
import type { NextAuthOptions } from "next-auth";

import {
  AuthenticationResponse,
  Credentials,
  LocalStorageSession,
  authenticateWithCredentials,
  authenticateWithGoogle,
  confirmEmail,
  getSessionById,
  resetPassword,
} from "../../../api";
import {
  ConfirmEmailMutationVariables,
  SessionType_Enum,
} from "generated-graphql";
import { HASURA_ALLOWED_ROLES, UserRole } from "../../../common";
import { refreshSession } from "../../../api/services/refreshSession";
import { JWT } from "next-auth/jwt";

type SessionJwt = {
  userId?: string;
  userRole?: UserRole;
  sessionId?: string;
  sessionType?: SessionType_Enum;
};

const jwtSecret = JSON.parse(process.env.AUTH_PRIVATE_KEY);

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: "credentials",
      credentials: {
        email: { label: "email", type: "text", placeholder: "jsmith" },
        password: { label: "Password", type: "password" },
      },
      // @ts-ignore
      async authorize(
        credentials: Partial<Credentials> | undefined
      ): Promise<AuthenticationResponse> {
        if (!credentials) {
          return null;
        }
        let authResponse: AuthenticationResponse;
        if (credentials.passwordResetToken) {
          authResponse = await resetPassword(credentials as Credentials);
        } else if (credentials.emailConfirmationToken) {
          authResponse = await confirmEmail(
            credentials as ConfirmEmailMutationVariables
          );
        } else if (credentials.sessionId) {
          // Allow signing in with a sessionId that was generated by the backend.
          authResponse = {
            sessionId: credentials.sessionId,
          };
        } else {
          authResponse = await authenticateWithCredentials(credentials);
        }
        return authResponse;
      },
    }),
    // Google provider
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID ?? "",
      clientSecret: process.env.GOOGLE_CLIENT_SECRET ?? "",
      authorization: {
        params: {
          prompt: "consent",
          access_type: "offline",
          response_type: "code",
        },
      },
      // @ts-ignore
      profile: async (profile) => {
        const authResult = await authenticateWithGoogle({
          email: profile.email,
          username: profile.given_name,
        });

        return authResult;
      },
    }),
  ],

  debug: true,

  // Use JWT strategy so we can forward them to Hasura
  session: { strategy: "jwt" },
  // Encode and decode your JWT with the HS256 algorithm
  jwt: {
    encode: ({ token }) => {
      const encodedToken = jwt.sign(token, jwtSecret.key, {
        algorithm: jwtSecret.type,
      });
      return encodedToken;
    },
    decode: ({ token }) => {
      const decodedToken = jwt.verify(token, jwtSecret.key, {
        algorithms: jwtSecret.type,
      });

      return decodedToken;
    },
  },
  pages: {
    signIn: "/login",
    // signOut: '/auth/signout', // Displays form with sign out button
    // error: '/auth/error', // Error code passed in query string as ?error=
    // verifyRequest: '/auth/verify-request', // Used for check email page
    // newUser: null // If set, new users will be directed here on first sign in
  },
  callbacks: {
    // Add the required Hasura claims
    // https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/#the-spec
    async jwt({
      token: sessionJwt,
      user: authenticationResultData,
      //profile,
      account,
    }): Promise<SessionJwt> {
      // first login: account and user are filled
      if (account && authenticationResultData) {
        const sessionFromDb = await getSessionById(
          authenticationResultData?.sessionId as string
        );
        return {
          sessionId: authenticationResultData?.sessionId,
          sessionFromDb,
        } as SessionJwt;
      }
      const sessionFromDb = await getSessionById(
        sessionJwt?.sessionId as string
      );
      // second access user and account are undefined
      return { ...sessionJwt, sessionFromDb } as SessionJwt;
    },
    // after the second access of jwt
    async session({ session: _session, token }): Promise<
      LocalStorageSession & { expires: string; token: string } // "expires" is added for compatibility reasons only; It's not actually being used anywhere
    > {
      if (!token.sessionId) {
        console.log("Missing sessionId");
        // @ts-ignore
        return {} as LocalStorageSession & { expires: string };
      }

      if (!token.sessionFromDb) {
        console.log("Session not found");
        // @ts-ignore
        return {} as LocalStorageSession & { expires: string };
      }

      if (new Date(token.sessionFromDb.expires) <= new Date()) {
        console.log("Session expired");
        // @ts-ignore
        return {} as LocalStorageSession & { expires: string };
      }

      const localStorageSession: LocalStorageSession = {
        sessionId: token?.sessionId,
        sessionType: token?.sessionFromDb.type,
        userId: token?.sessionFromDb.userId,
        userRole: token?.sessionFromDb.userRole,
      };

      const hasuraClaims = {
        "https://hasura.io/jwt/claims": {
          "x-hasura-allowed-roles": HASURA_ALLOWED_ROLES,
          "x-hasura-default-role": UserRole.Unauthenticated,
          "x-hasura-user-id": token?.sessionFromDb?.userId,
        },
      };
      const encodedToken = jwt.sign(
        {
          ...localStorageSession,
          ...hasuraClaims,
        },
        jwtSecret.key,
        {
          algorithm: jwtSecret.type,
        }
      );

      // TODO: throttle session update (and potentially even the session querying)
      // TODO: Potentially use direct db access instead of api for performance reasons [#944]
      refreshSession(localStorageSession);
      return Promise.resolve({
        ...localStorageSession,
        expires: "", // for compatibility only, not actually being used
        token: encodedToken,
      });
    },
  },
};

const Auth = (req: NextApiRequest, res: NextApiResponse) => {
  return NextAuth(req, res, authOptions);
};

export default Auth;
